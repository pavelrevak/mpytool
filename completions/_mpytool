#compdef mpytool

# ZSH completion for mpytool
# Install: copy to ~/.zsh/completions/_mpytool and add to fpath

# Cache for remote paths (per port+dir)
typeset -gA _mpytool_cache
typeset -gA _mpytool_cache_time

_mpytool_commands() {
    local -a commands=(
        'ls:list files on device'
        'tree:show directory tree'
        'cat:print file content (: prefix for device path)'
        'cp:copy files (: prefix for device paths)'
        'mv:move/rename files on device (: prefix)'
        'mkdir:create directory (: prefix for device path)'
        'rm:delete files/directories (: prefix for device path)'
        'pwd:print current working directory'
        'cd:change current working directory (: prefix)'
        'stop:stop running program (Ctrl-C)'
        'monitor:monitor device output (Ctrl+C to exit)'
        'repl:interactive REPL session'
        'exec:execute Python code on device'
        'run:run local Python file on device'
        'reset:reset device (soft/machine/rts/raw/boot/dtr-boot)'
        'info:show device information'
        'flash:flash/partition operations (list, read, write, erase)'
        'ota:OTA firmware update (ESP32)'
        'mount:mount local directory on device (readonly)'
        'sleep:sleep for specified seconds'
        'speedtest:serial link speed test'
    )
    _describe -t commands 'mpytool command' commands
}

_mpytool_detect_ports() {
    # Detect serial ports based on platform (same logic as mpytool)
    local -a ports=()
    case "$(uname)" in
        Darwin)
            # macOS: use cu.* (call-up) instead of tty.*
            for p in /dev/cu.usbmodem* /dev/cu.usbserial* /dev/cu.usb*; do
                [[ -e "$p" ]] && ports+=("$p")
            done
            ;;
        Linux)
            for p in /dev/ttyACM* /dev/ttyUSB*; do
                [[ -e "$p" ]] && ports+=("$p")
            done
            ;;
    esac
    # Remove duplicates and sort
    echo "${(u)ports[@]}" | tr ' ' '\n' | sort -u
}

_mpytool_ports() {
    # Complete serial ports
    local -a ports
    ports=(${(f)"$(_mpytool_detect_ports)"})
    [[ ${#ports[@]} -gt 0 ]] && compadd -a ports
}

_mpytool_get_port() {
    # Use global _mpytool_current_port if set (from main function)
    if [[ -n "$_mpytool_current_port" ]]; then
        echo "$_mpytool_current_port"
        return
    fi

    # Fallback: auto-detect only if single port available
    local -a ports
    ports=(${(f)"$(_mpytool_detect_ports)"})
    if [[ ${#ports[@]} -eq 1 ]]; then
        echo "${ports[1]}"
    fi
}

_mpytool_complete_remote() {
    # $1 = "dirs" for directories only (optional)
    local dirs_only="$1"

    # Use compset to handle : and path prefixes (like _files does)
    # This sets IPREFIX so compadd -S '/' works correctly
    compset -P ':'
    compset -P '*/'
    # IPREFIX now contains the directory part (e.g., ":", ":/lib/", ":lib/sub/")
    # PREFIX contains the partial filename being completed

    local dir_query="${IPREFIX}"

    # Get port
    local port=$(_mpytool_get_port)
    if [[ -z "$port" ]]; then
        compadd -x 'no device connected'
        return
    fi

    # Cache per (port, dir_query), 10 seconds
    local cache_key="${port//\//_}_${dir_query}"
    local now=$(date +%s)
    local cache_age=$((now - ${_mpytool_cache_time[$cache_key]:-0}))

    local -a entries=()
    if [[ $cache_age -lt 10 && -n "${_mpytool_cache[$cache_key]}" ]]; then
        entries=(${(f)_mpytool_cache[$cache_key]})
    else
        local output
        output=$(mpytool -p "$port" _paths "$dir_query" 2>/dev/null)
        if [[ $? -ne 0 ]]; then
            compadd -x 'cannot read device'
            return
        fi
        entries=("${(@f)output}")
        _mpytool_cache[$cache_key]="${(F)entries}"
        _mpytool_cache_time[$cache_key]=$now
    fi

    # Add completions - compset already handles the prefix via IPREFIX
    # -S '/' -q for directories: removable suffix (bold, Tab enters, Space removes)
    # -d for display: show names with / in menu to distinguish from files
    local -a dirs=() dirs_display=() files=()
    local e
    for e in "${entries[@]}"; do
        [[ -z "$e" ]] && continue
        if [[ "$e" == */ ]]; then
            dirs+=("${e%/}")
            dirs_display+=("$e")
        else
            files+=("$e")
        fi
    done

    [[ ${#dirs[@]} -gt 0 ]] && compadd -S '/' -q -d dirs_display -- "${dirs[@]}"
    [[ -z "$dirs_only" && ${#files[@]} -gt 0 ]] && compadd -- "${files[@]}"
}

_mpytool_clear_cache() {
    # Call this to clear the remote file cache
    _mpytool_cache=()
    _mpytool_cache_time=()
}

_mpytool() {
    local curcontext="$curcontext" state state_descr line
    typeset -A opt_args

    _arguments -C \
        '-V[show version]' \
        '--version[show version]' \
        '-p[serial port]:port:_mpytool_ports' \
        '--port[serial port]:port:_mpytool_ports' \
        '-a[network address]:address:' \
        '--address[network address]:address:' \
        '-b[baud rate]:baud:(9600 19200 38400 57600 115200 230400 460800 921600)' \
        '--baud[baud rate]:baud:(9600 19200 38400 57600 115200 230400 460800 921600)' \
        '-d[debug level]' \
        '--debug[debug level]' \
        '-v[verbose output]' \
        '--verbose[verbose output]' \
        '-q[quiet mode]' \
        '--quiet[quiet mode]' \
        '-f[force copy]' \
        '--force[force copy]' \
        '-e[exclude directory]:dir:_files -/' \
        '--exclude-dir[exclude directory]:dir:_files -/' \
        '*::command:->commands'

    # Set port for helper functions to use
    _mpytool_current_port="${opt_args[-p]:-${opt_args[--port]:-}}"

    case "$state" in
        commands)
            # Find the last -- separator and work relative to it
            local cmd_start=1
            local i
            for ((i=1; i < CURRENT; i++)); do
                if [[ "${words[i]}" == "--" ]]; then
                    cmd_start=$((i + 1))
                fi
            done

            local cmd="${words[cmd_start]}"
            local pos=$((CURRENT - cmd_start + 1))

            # If at command position (right after -- or at start), complete commands
            if [[ $CURRENT -eq $cmd_start ]]; then
                _mpytool_commands
                return
            fi

            # If current word is --, offer commands for next position
            if [[ "${words[CURRENT]}" == "--" ]]; then
                return
            fi

            # Command-specific completions (pos is position within current command group)
            # pos=2 is first arg after command, pos=3 is second, etc.
            local nargs=$((pos - 2))  # number of already completed args
            case "$cmd" in
                ls|tree)
                    # Optional remote path, -- anytime
                    if [[ $pos -eq 2 ]]; then
                        if [[ "$words[CURRENT]" == :* ]]; then
                            _mpytool_complete_remote
                        else
                            compadd -S '' ':'
                        fi
                    fi
                    compadd -- '--'
                    ;;
                cat)
                    # 1+ remote files required, -- after at least one
                    if [[ "$words[CURRENT]" == :* ]]; then
                        _mpytool_complete_remote
                    else
                        compadd -S '' ':'
                    fi
                    [[ $nargs -ge 1 ]] && compadd -- '--'
                    ;;
                mkdir|rm)
                    # 1+ remote paths required, -- after at least one
                    if [[ "$words[CURRENT]" == :* ]]; then
                        _mpytool_complete_remote
                    else
                        compadd -S '' ':'
                    fi
                    [[ $nargs -ge 1 ]] && compadd -- '--'
                    ;;
                mv)
                    # 2+ remote paths required, -- after at least two
                    if [[ "$words[CURRENT]" == :* ]]; then
                        _mpytool_complete_remote
                    else
                        compadd -S '' ':'
                    fi
                    [[ $nargs -ge 2 ]] && compadd -- '--'
                    ;;
                cd)
                    # Exactly 1 remote dir, -- only after it
                    if [[ $pos -eq 2 ]]; then
                        if [[ "$words[CURRENT]" == :* ]]; then
                            _mpytool_complete_remote 'dirs'
                        else
                            compadd -S '' ':'
                        fi
                    else
                        compadd -- '--'
                    fi
                    ;;
                cp)
                    # n local + 1 remote OR n remote + 1 local
                    # Count local and remote args (excluding current word)
                    local n_local=0 n_remote=0
                    for ((i=cmd_start+1; i < CURRENT; i++)); do
                        if [[ "${words[i]}" == :* ]]; then
                            ((n_remote++))
                        else
                            ((n_local++))
                        fi
                    done
                    if [[ $n_local -ge 1 && $n_remote -ge 1 ]]; then
                        # Complete, only offer --
                        compadd -- '--'
                    else
                        # Need more args, offer files and :
                        if [[ "$words[CURRENT]" == :* ]]; then
                            _mpytool_complete_remote
                        else
                            _files
                            compadd -S '' ':'
                        fi
                    fi
                    ;;
                exec)
                    # 1 code string, -- after it
                    [[ $nargs -ge 1 ]] && compadd -- '--'
                    ;;
                run)
                    # 1 local .py file, -- after it
                    if [[ $pos -eq 2 ]]; then
                        _files -g '*.py'
                    fi
                    [[ $nargs -ge 1 ]] && compadd -- '--'
                    ;;
                pwd)
                    # No arguments, -- immediately
                    compadd -- '--'
                    ;;
                reset)
                    # Reset flags or --
                    local -a reset_flags=(
                        '--machine:machine.reset() with reconnect'
                        '--rts:hardware reset via DTR/RTS signal'
                        '--raw:soft reset in raw REPL'
                        '--boot:enter bootloader (machine.bootloader)'
                        '--dtr-boot:bootloader via DTR/RTS (ESP32)'
                        '-t:reconnect timeout in seconds'
                    )
                    local has_mode=0
                    for w in "${words[cmd_start+1,-1]}"; do
                        case "$w" in
                            --machine|--rts|--raw|--boot|--dtr-boot) has_mode=1 ;;
                        esac
                    done
                    if [[ $has_mode -eq 0 ]]; then
                        _describe -t flags 'reset flag' reset_flags
                    fi
                    compadd -- '--'
                    ;;
                stop|info)
                    # No arguments, -- immediately
                    compadd -- '--'
                    ;;
                repl|monitor)
                    # Interactive, no chaining
                    ;;
                flash)
                    # flash [read|write|erase] [label] [file]
                    local flash_subcmd="${words[cmd_start+1]}"
                    if [[ $pos -eq 2 ]]; then
                        local -a subcmds=(
                            'read:read flash/partition to file'
                            'write:write file to flash/partition'
                            'erase:erase flash/partition'
                        )
                        _describe -t subcmds 'flash subcommand' subcmds
                    elif [[ $pos -eq 3 && "$flash_subcmd" == "erase" ]]; then
                        compadd -- '--full'
                        compadd -- '--'
                    elif [[ $pos -eq 3 ]]; then
                        # read/write: label (device-specific, no completion)
                        :
                    elif [[ $pos -eq 4 && "$flash_subcmd" != "erase" ]]; then
                        _files
                    elif [[ "$flash_subcmd" == "erase" ]]; then
                        compadd -- '--full'
                        compadd -- '--'
                    fi
                    # -- after complete subcommand
                    if [[ "$flash_subcmd" == "erase" && $pos -ge 3 ]]; then
                        :  # already handled above
                    elif [[ "$flash_subcmd" != "erase" && $pos -ge 5 ]]; then
                        compadd -- '--'
                    fi
                    ;;
                ota)
                    # 1 firmware file, -- after it
                    if [[ $pos -eq 2 ]]; then
                        _files -g "*.bin"
                    else
                        compadd -- '--'
                    fi
                    ;;
                sleep)
                    # 1 number, -- after it
                    [[ $nargs -ge 1 ]] && compadd -- '--'
                    ;;
                mount)
                    # 1 local dir + optional :mount_point, no -- (auto-repl)
                    if [[ $pos -eq 2 ]]; then
                        _files -/
                    elif [[ $pos -eq 3 ]]; then
                        compadd -S '' ':'
                    fi
                    ;;
                speedtest)
                    # No arguments, -- immediately
                    compadd -- '--'
                    ;;
                --)
                    _mpytool_commands
                    ;;
                *)
                    _mpytool_commands
                    ;;
            esac
            ;;
    esac
}

# Only run if called as completion (not when sourced)
if [[ -n "$compstate" ]]; then
    _mpytool "$@"
fi
