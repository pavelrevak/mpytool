#compdef mpytool

# ZSH completion for mpytool
# Install: copy to ~/.zsh/completions/_mpytool and add to fpath

# Cache for remote files (per port)
typeset -gA _mpytool_cache
typeset -gA _mpytool_cache_time

_mpytool_commands() {
    local -a commands=(
        'ls:list files on device'
        'tree:show directory tree'
        'cat:print file content (: prefix for device path)'
        'cp:copy files (: prefix for device paths)'
        'mv:move/rename files on device (: prefix)'
        'mkdir:create directory (: prefix for device path)'
        'rm:delete files/directories (: prefix for device path)'
        'monitor:monitor device output (Ctrl+C to exit)'
        'repl:interactive REPL session'
        'exec:execute Python code on device'
        'reset:soft reset device (Ctrl-D)'
        'sreset:soft reset in raw REPL (clears RAM only)'
        'mreset:MCU reset (machine.reset, auto-reconnect)'
        'rtsreset:hardware reset via RTS signal'
        'bootloader:enter bootloader (machine.bootloader)'
        'dtrboot:enter bootloader via DTR/RTS (ESP32)'
        'info:show device information'
        'flash:flash/partition operations (list, read, write, erase)'
        'ota:OTA firmware update (ESP32)'
        'sleep:sleep for specified seconds'
    )
    _describe -t commands 'mpytool command' commands
}

_mpytool_detect_ports() {
    # Detect serial ports based on platform (same logic as mpytool)
    local -a ports=()
    case "$(uname)" in
        Darwin)
            # macOS: use cu.* (call-up) instead of tty.*
            for p in /dev/cu.usbmodem* /dev/cu.usbserial* /dev/cu.usb*; do
                [[ -e "$p" ]] && ports+=("$p")
            done
            ;;
        Linux)
            for p in /dev/ttyACM* /dev/ttyUSB*; do
                [[ -e "$p" ]] && ports+=("$p")
            done
            ;;
    esac
    # Remove duplicates and sort
    echo "${(u)ports[@]}" | tr ' ' '\n' | sort -u
}

_mpytool_ports() {
    # Complete serial ports
    local -a ports
    ports=(${(f)"$(_mpytool_detect_ports)"})
    [[ ${#ports[@]} -gt 0 ]] && compadd -a ports
}

_mpytool_get_port() {
    # Use global _mpytool_current_port if set (from main function)
    if [[ -n "$_mpytool_current_port" ]]; then
        echo "$_mpytool_current_port"
        return
    fi

    # Fallback: auto-detect only if single port available
    local -a ports
    ports=(${(f)"$(_mpytool_detect_ports)"})
    if [[ ${#ports[@]} -eq 1 ]]; then
        echo "${ports[1]}"
    fi
}

_mpytool_fetch_paths() {
    # Fetch and cache paths, returns via $_mpytool_cached_files array
    local port=$(_mpytool_get_port)
    [[ -z "$port" ]] && return 1

    local cache_key="${port//\//_}"
    local now=$(date +%s)
    local cache_age=$((now - ${_mpytool_cache_time[$cache_key]:-0}))

    # Use cache if less than 60 seconds old
    if [[ $cache_age -lt 60 && -n "${_mpytool_cache[$cache_key]}" ]]; then
        _mpytool_cached_files=(${(f)_mpytool_cache[$cache_key]})
        return 0
    fi

    # Fetch file list from device using _paths command
    local output
    output=$(mpytool -p "$port" _paths 2>/dev/null)
    if [[ $? -ne 0 ]]; then
        return 1
    fi

    # Split output into array (one path per line)
    _mpytool_cached_files=("${(@f)output}")

    # Cache results
    _mpytool_cache[$cache_key]="${(F)_mpytool_cached_files}"
    _mpytool_cache_time[$cache_key]=$now
    return 0
}

_mpytool_complete_remote() {
    # $1 = colon prefix (":" or "")
    local colon_prefix="$1"
    local -a _mpytool_cached_files=()
    _mpytool_fetch_paths || return 1

    local cur="${words[CURRENT]}"
    # Remove leading : for processing
    cur="${cur#:}"

    local prefix=""
    local filter=""

    # Handle absolute vs relative paths
    if [[ "$cur" == "/"* ]]; then
        prefix="/"
        filter="${cur#/}"
    else
        filter="$cur"
    fi

    # Extract directory part (everything up to and including last /)
    local dir_part=""
    if [[ "$filter" == */* ]]; then
        dir_part="${filter%/*}/"
    fi

    # Filter and show only direct children of current directory
    local -a matches=()
    local f child
    for f in "${_mpytool_cached_files[@]}"; do
        # Check if file is in the target directory
        if [[ -n "$dir_part" ]]; then
            [[ "$f" != "$dir_part"* ]] && continue
            child="${f#$dir_part}"
        else
            child="$f"
        fi

        # If child contains /, show parent dir instead
        if [[ "$child" == */* ]]; then
            child="${child%%/*}/"
        fi

        local full="${prefix}${dir_part}${child}"

        # Avoid duplicates
        if [[ ! " ${matches[*]} " =~ " ${full} " ]]; then
            matches+=("$full")
        fi
    done

    # Add with appropriate suffix (none for dirs, space for files)
    local -a dirs=() files=()
    for f in "${matches[@]}"; do
        if [[ "$f" == */ ]]; then
            dirs+=("$f")
        else
            files+=("$f")
        fi
    done

    if [[ -n "$colon_prefix" ]]; then
        [[ ${#dirs[@]} -gt 0 ]] && compadd -p ':' -S '' -a dirs
        [[ ${#files[@]} -gt 0 ]] && compadd -p ':' -a files
    else
        [[ ${#dirs[@]} -gt 0 ]] && compadd -S '' -a dirs
        [[ ${#files[@]} -gt 0 ]] && compadd -a files
    fi
}

_mpytool_remote_files() {
    _mpytool_complete_remote ':'
}

_mpytool_clear_cache() {
    # Call this to clear the remote file cache
    _mpytool_cache=()
    _mpytool_cache_time=()
}

_mpytool() {
    local curcontext="$curcontext" state state_descr line
    typeset -A opt_args

    _arguments -C \
        '-V[show version]' \
        '--version[show version]' \
        '-p[serial port]:port:_mpytool_ports' \
        '--port[serial port]:port:_mpytool_ports' \
        '-a[network address]:address:' \
        '--address[network address]:address:' \
        '-b[baud rate]:baud:(9600 19200 38400 57600 115200 230400 460800 921600)' \
        '--baud[baud rate]:baud:(9600 19200 38400 57600 115200 230400 460800 921600)' \
        '-d[debug level]' \
        '--debug[debug level]' \
        '-v[verbose output]' \
        '--verbose[verbose output]' \
        '-q[quiet mode]' \
        '--quiet[quiet mode]' \
        '-f[force copy]' \
        '--force[force copy]' \
        '-e[exclude directory]:dir:_files -/' \
        '--exclude-dir[exclude directory]:dir:_files -/' \
        '*::command:->commands'

    # Set port for helper functions to use
    _mpytool_current_port="${opt_args[-p]:-${opt_args[--port]:-}}"

    case "$state" in
        commands)
            # Find the last -- separator and work relative to it
            local cmd_start=1
            local i
            for ((i=1; i < CURRENT; i++)); do
                if [[ "${words[i]}" == "--" ]]; then
                    cmd_start=$((i + 1))
                fi
            done

            local cmd="${words[cmd_start]}"
            local pos=$((CURRENT - cmd_start + 1))

            # If at command position (right after -- or at start), complete commands
            if [[ $CURRENT -eq $cmd_start ]]; then
                _mpytool_commands
                return
            fi

            # If current word is --, offer commands for next position
            if [[ "${words[CURRENT]}" == "--" ]]; then
                return
            fi

            # Command-specific completions (pos is position within current command group)
            case "$cmd" in
                ls|tree|cat|mkdir|rm|mv)
                    # These require : prefix for device paths
                    if [[ "$words[CURRENT]" == :* ]]; then
                        _mpytool_remote_files
                    else
                        compadd -S '' ':'
                    fi
                    ;;
                cp)
                    # cp: either arg can be local or remote (: prefix for device)
                    if [[ "$words[CURRENT]" == :* ]]; then
                        _mpytool_remote_files
                    else
                        _files
                        compadd -S '' ':'
                    fi
                    ;;
                exec)
                    # exec takes Python code, no completion
                    ;;
                repl|monitor|reset|sreset|mreset|rtsreset|bootloader|dtrboot|info)
                    # No arguments
                    ;;
                flash)
                    # flash [read|write|erase] [label] [file]
                    local flash_subcmd="${words[cmd_start+1]}"
                    if [[ $pos -eq 2 ]]; then
                        local -a subcmds=(
                            'read:read flash/partition to file'
                            'write:write file to flash/partition'
                            'erase:erase flash/partition'
                        )
                        _describe -t subcmds 'flash subcommand' subcmds
                    elif [[ $pos -eq 3 && "$flash_subcmd" == "erase" ]]; then
                        # erase: optional label or --full
                        compadd -- '--full'
                    elif [[ $pos -eq 3 ]]; then
                        # read/write: label (device-specific, no completion)
                        :
                    elif [[ $pos -eq 4 && "$flash_subcmd" != "erase" ]]; then
                        # read/write: file
                        _files
                    elif [[ "$flash_subcmd" == "erase" ]]; then
                        compadd -- '--full'
                    fi
                    ;;
                ota)
                    # ota takes firmware file
                    _files -g "*.bin"
                    ;;
                sleep)
                    # sleep takes number, no completion
                    ;;
                --)
                    # After --, complete commands
                    _mpytool_commands
                    ;;
                *)
                    # Unknown command or first position
                    _mpytool_commands
                    ;;
            esac

            # Always offer -- to chain commands
            compadd -- '--'
            ;;
    esac
}

# Only run if called as completion (not when sourced)
if [[ -n "$compstate" ]]; then
    _mpytool "$@"
fi
